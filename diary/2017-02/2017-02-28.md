# 2017년 2월 28일(화)

## Screeps
rx.lite.js 정도는 임포트해서 써볼 만도 할 것 같은데.
근데 lodash로 충분하지 않을까 싶기도 하고. NodeJS에서 커스텀이벤트 같은 게 먹히려나? 아마 screeps의 루프 아키텍처 때문에 씹힐 것 같다. 애초에 screeps는 비동기성이 전혀 없다. 동기 루프를 돌면서 오직 Memory객체만이 상태를 저장하는 형태다. 비동기 IO처리 전부가 거절되는 환경이다. 다만 스트림 필터 같은건 도입할 수 있을지도 모르겠다. 물론 이런 LISP스타일 코딩은 lodash로도 차고 넘친다는거.

GCL은 한참 남았지만 RCL은 곧 2, 3번방 모두 오늘 안에 6레벨 찍을 것 같다. 1번방을 위해 리모트 하베스터를 잔뜩 만드는 것도 고려할 수 있다.
내일이 삼일절이니까 만져볼 만 하지.

15시 현재, 3번방이 RCL6 달성. 2번방보다 빠르다. 물론 소스 한개짜리 2번방보다 소스 두개짜리인 3번방이 업그레이드가 빠를 수밖에 없긴 하다.
2번방은 버리기엔 방어가 워낙에 튼튼해서 아깝단 말이지. 하지만 GCL은 아직 멀었고, 방어가 더 튼튼한 방이 존재하기도 하고. 단, 그 '방어가 더 튼튼한' 방은 공간이 좁아서 익스텐션 전개가 곤란하다.

그리고 새틀러가 방이동할 때는

http://support.screeps.com/hc/en-us/articles/203079191-Map#findRoute

이 함수를 쓰는 게 낫다. 약간 아래쪽에 고속도로 이용하는 스크립트도 있다.

http://support.screeps.com/hc/en-us/articles/203079011-Room#serializePath



 Room.serializePath(PathFinder.search(new RoomPosition(24,27,'W66S41'),new RoomPosition(14,33,'W66S41')).path);

는 이상하게 작동한다. 웬 undefined 가 한가득이다.

 Room.serializePath(Game.rooms.W66S41.findPath(new RoomPosition(24,27,'W66S41'),new RoomPosition(14,33,'W66S41')));

가 작동한다. Room.findPath 는 작동하지 않는다. 어휴. 하여튼 이거 리턴값이 232688777777777666554443 이다. 아무래도 크립의 이동방향인 8방향에 대한 리스트같다.
TOP = 1
TOP_RIGHT = 2
RIGHT = 3
BOTTOM_RIGHT = 4
BOTTOM = 5
BOTTOM_LEFT = 6
LEFT = 7
TOP_LEFT = 8

이다. 살짝 돌아가는 경로를 택한 것 같은데 뭐 대충 맞다.
패스파인더를 직렬화하는 건 내가 알아서 하란건가? 흠...

creep.pos.getDirectionTo 함수가 있긴 한데, 그러니까 RoomPosition.getDirectionTo 말이다. CPU COST: LOW 다. 뭐 일회성 계산에는 상관없으려나?
내가 직접 함수 만든다 치면, 방 넘어가는 부분에서 애매해질 수 있음.

http://support.screeps.com/hc/en-us/articles/203013212-Creep#moveByPath

이게 있긴 한데, 직렬화 요구가 있으니까 쓰나마나.

다만 PathFinder.use(true); 한 상태면 Room.findPath 도 이놈을 쓰게 바뀐다고 한다. Room.findPath, RoomPosition.findPathTo, RoomPosition.findClosestByPath, Creep.moveTo 가 영향을 받는다 한다.

그리고 크립의 move 동작은, 벽에 막혀서 못움직였어도 0이 리턴된다. 즉 직렬화한 패스를 그냥 역직렬화해서 쓰는데 중간에 뭐가 길막하면 패스 전체가 싹 꼬인다는 뜻이다. 외부에서 크립을 '밀어버리는' 동작은 일단 불가하므로 현위치 체크를 해야 할 것 같다. 이래서 패스파인더가 RoomPosition 배열을 담았나?
하지만 CPU를 최대한 줄여야지. 최소한 같은 방 안에서 움직이는 크립들에 대해서는. 근데 생각해보니 하베스터나 업그레이더는 고정 라우팅이 가능해도 디플로이어나 빌더는 안 되네. 하베스터도 소스에 한 번 붙으면 거기서 캐다가 죽는 놈이고. 결국 새틀러와 리모트 하베스터에만 패스 직렬화 적용이 가능하겠군.

뭐 생각해보면 GCL을 10넘게 끌어올리려면 상상할 수 있는 최대 효율을 내도 몇 달은 걸릴 것이다. 내 저효율 코드로 겨우 GCL 3 획득하는데 한 달이 걸렸다. 랭커들도 GCL은 16정도. 공간복잡도에는 여유가 많다.

근데 진짜 GCL4 도달하려면 한 달이 추가로 걸릴 판이다. 업그레이더가 더 고성능이어야 한다. 허나 지금보다 소비속도가 늘어나면 에너지 밸런스가 깨질 것이다. 이미 3번방은 소비가 더 많게 세팅돼있다. 여기서 더 늘릴 수가 없다. 리모트 하베스터를 대규모로 굴리지 않는 한에는 말이다.

https://arcath.net/category/screeps/

헐?

하지만 이 사람, 나보다 코딩 능력 떨어지는 게 분명하다. 나보다 RCL이 딸린다. GCL은 4지만 이사람 작년 11월부터 했다. 늪지대 매립 문제가 있었다곤 해도 도로를 지나치게 많이 깔았다. 룸 레벨 666이라... 절묘하다. 업그레이더가 너무 허접해서 RCL7에 도달하질 못했다. 아마 방어는 타워에 전담하겠지? 이러면 호전적인 플레이어가 쳐들어왔을 때 심각하게 피해를 입게 된다. 심지어 고성능 인베이더에도 털릴 수 있다. 전시 대비가 전혀 안 돼있다. 뭐 나야 바로 머리 위에 Atanner라는 바바리안(!)이 있어서 이렇게 된 거긴 하다만.

GeneBuilder에 제한효소 요소를 두자. 마디 단위로 잘리게. 현재처럼 바디파트 개별단위로 잘리지 말고.
그냥 '/' 이라고 표시하면 되겠지.

그리고 하베스터의 Affinity 를 타겟 기반으로 수정을 해야겠다. 소스 하나당 크립 하나가 붙는다고 해야지. 지금처럼 두 놈 붙여봐야 헛짓이다.
그리고 디플로이어가 멀쩡히 살아있을 때는 좀 기다렸다가 풀 크립으로 생성하게 해주는 게 낫지 않을까?
근데 스포너가 이런 것까지 신경써야 하나?
